# 1. Chapter 01 - 깨끗한 코드

1. 나쁜 코드를 작성하지 않아야 하는 이유

- 개발 속도를 떨어뜨림
- 간단한 변경도 어렵게 만듦

2. 코드를 최대한 깨끗하게 유지하는 습관

### 저명한 인사들의 깨끗한 코드의 기준 혹은 정의

**비야네 스트롭스트룹**

1. 간단한 논리
2. 의존성은 최대한 적게
3. 오류는 전략에 따라 철처하게 처리 → 대충 넘어가지 않고 꼼꼼하고 세심하게
4. 한 가지를 제대로 (단일책임)
5. 우아한 → 보기에 즐거운
6. 효율적인 → 속도를 비롯하여 CPU 등의 자원을 낭비하지 않는 코드

→ 세세한 사항까지 꼼꼼하게 처리하는 코드

**그래디 부치**

1. 단순하고 직접적인 코드
2. 잘 쓴 문장처럼 읽히는 코드 → 가독성
3. 명쾌한 추상화 → 추측이 아닌 반드시 필요한 내용만 담은 사실에 기반하도록

**큰 데이브 토마스**

1. 작성자가 아닌 다른 사람도 고치기 쉬운 코드
2. 단위 테스트 케이스와 인수 테스트 케이스 존재
3. 목적을 달성하는 방법은 한 가지만 제공
4. 최소한의 의존성

**마이클 페더스**

1. 주의를 기울인 코드

**론 제프리스**

1. 모든 테스트를 통과
2. 중복이 없음
3. 모든 설계 아이디어를 표현
4. 최소한의 클래스, 메서드, 함수
5. 의미 있는 이름 → 표현력 높이기
6. 한 가지 기능만
7. 작게 추상화

**워드 커닝햄**

1. 읽으면서 짐작했던 기능들을 그대로 수행
2. 언어가 단순하게 보이도록

### 내가 생각하는 깨끗한 코드

1. 작은 단위로 쪼갠 함수
   - 로직에 이름이 생겨서 코드를 끝까지 다 읽지 않아도 어떤 동작을 할 지 유추할 수 있음

```jsx
if (code === 800) {
  setNameValue("");
  setNameStatus("error");
  nameInputRef.current.focus();
}

if (code === 800) {
  handleDuplicateNameError();
}

function handleDuplicateNameError() {
  setNameValue("");
  setNameStatus("error");
  nameInputRef.current.focus();
}
```

2. 내장 메서드 사용
   - 얻으려고 하는 값의 데이터 타입과 목적을 빠르게 유추할 수 있음

```jsx
const filteredList = [];

for (let i = 0; i < array.length; i++) {
  if (array[i].length > 5) {
    filteredList.push(array[i]);
  }
}

const filteredList = array.filter((x) => x.length > 5);
```

3. 조건문의 깊이가 깊지 않은 코드

- 어떤 조건에서 실행되는지 한 눈에 파악 가능

```jsx
if () {
   if () {
      if () {

      }
   }
}

if () {}

if () {}

if () {}
```
